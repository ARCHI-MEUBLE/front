<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Prototype ArchiMeuble - NextGen 3D</title>
    <script async src="https://unpkg.com/es-module-shims@1.8.0/dist/es-module-shims.js"></script>
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Plus+Jakarta+Sans:wght@400;600;700&display=swap');
        
        body { margin: 0; font-family: 'Plus Jakarta Sans', sans-serif; background: #ffffff; overflow: hidden; display: flex; height: 100vh; width: 100vw; color: #1a1a1a; }
        
        #canvas-container { flex: 1; height: 100vh; position: relative; background: #f8f8f8; }
        
        #ui { 
            width: 400px; 
            height: 100vh; 
            background: white; 
            z-index: 100; 
            padding: 40px; 
            display: flex; 
            flex-direction: column; 
            overflow-y: auto;
            border-left: 1px solid #f0f0f0;
        }

        .brand { font-size: 12px; font-weight: 700; text-transform: uppercase; letter-spacing: 2px; color: #999; margin-bottom: 10px; }
        h1 { font-size: 28px; margin-top: 0; color: #000; font-weight: 700; letter-spacing: -1px; margin-bottom: 40px; }
        
        .section-title { font-size: 11px; font-weight: 700; text-transform: uppercase; letter-spacing: 1px; color: #000; margin-bottom: 20px; display: block; border-bottom: 1px solid #eee; padding-bottom: 10px; }
        
        .control-group { margin-bottom: 35px; }
        
        .label-row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; }
        label { font-size: 14px; color: #555; font-weight: 500; }
        .value { font-weight: 700; color: #000; font-size: 14px; background: #f5f5f5; padding: 4px 10px; border-radius: 6px; }
        
        input[type="range"] { width: 100%; cursor: pointer; height: 2px; background: #eee; -webkit-appearance: none; outline: none; }
        input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; height: 20px; width: 20px; border-radius: 50%; background: #000; border: 4px solid #fff; box-shadow: 0 2px 10px rgba(0,0,0,0.1); cursor: pointer; transition: all 0.2s; }
        input[type="range"]:active::-webkit-slider-thumb { transform: scale(1.2); box-shadow: 0 5px 15px rgba(0,0,0,0.2); }
        
        .color-grid { display: grid; grid-template-columns: repeat(5, 1fr); gap: 15px; margin-top: 10px; }
        .btn-color { aspect-ratio: 1; border-radius: 12px; border: 2px solid transparent; cursor: pointer; transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1); position: relative; }
        .btn-color:hover { transform: translateY(-3px); }
        .btn-color.active { border-color: #000; transform: scale(1.05); }
        .btn-color.active::after { content: '✓'; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #fff; font-size: 12px; mix-blend-mode: difference; }
        
        .toggle-row { display: flex; align-items: center; justify-content: space-between; padding: 15px 0; cursor: pointer; border-bottom: 1px solid #f9f9f9; }
        .toggle-row:last-child { border-bottom: none; }
        .toggle-label { font-size: 14px; font-weight: 600; }
        
        .switch { position: relative; display: inline-block; width: 44px; height: 22px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #eee; transition: .4s; border-radius: 34px; }
        .slider:before { position: absolute; content: ""; height: 16px; width: 16px; left: 3px; bottom: 3px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider { background-color: #000; }
        input:checked + .slider:before { transform: translateX(22px); }
        
        .hint { margin-top: auto; font-size: 12px; color: #999; line-height: 1.6; padding: 25px; background: #fafafa; border-radius: 20px; border: 1px dashed #eee; }
        .hint b { color: #000; display: block; margin-bottom: 5px; }

        #canvas-loader { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); pointer-events: none; opacity: 0; transition: opacity 0.5s; }
        #canvas-loader.visible { opacity: 1; }
        .spinner { width: 40px; height: 40px; border: 3px solid #eee; border-top: 3px solid #000; border-radius: 50%; animation: spin 1s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body>
    <div id="canvas-container">
        <div id="canvas-loader"><div class="spinner"></div></div>
        <div style="position: absolute; top: 40px; left: 40px; pointer-events: none;">
            <div class="brand" style="margin-bottom: 5px; color: #000;">Configurateur v5</div>
            <div style="font-size: 12px; color: #999;">Visualisation HD • Temps Réel</div>
        </div>
    </div>

    <div id="ui">
        <div class="brand">ArchiMeuble</div>
        <h1>Studio 3D</h1>
        
        <span class="section-title">Dimensions</span>
        <div class="control-group">
            <div class="label-row">
                <label>Largeur</label>
                <span class="value" id="val-width">150 cm</span>
            </div>
            <input type="range" id="input-width" min="50" max="300" value="150">
        </div>

        <div class="control-group">
            <div class="label-row">
                <label>Hauteur</label>
                <span class="value" id="val-height">200 cm</span>
            </div>
            <input type="range" id="input-height" min="50" max="250" value="200">
        </div>

        <div class="control-group">
            <div class="label-row">
                <label>Profondeur</label>
                <span class="value" id="val-depth">40 cm</span>
            </div>
            <input type="range" id="input-depth" min="20" max="80" value="40">
        </div>

        <span class="section-title">Structure</span>
        <div class="control-group">
            <div class="label-row">
                <label>Nombre d'étagères</label>
                <span class="value" id="val-shelves">4</span>
            </div>
            <input type="range" id="input-shelves" min="1" max="8" value="4">
        </div>

        <div class="control-group">
            <label class="toggle-row">
                <span class="toggle-label">Portes battantes</span>
                <div class="switch">
                    <input type="checkbox" id="check-doors" checked>
                    <span class="slider"></span>
                </div>
            </label>
            <label class="toggle-row">
                <span class="toggle-label">Socle de finition</span>
                <div class="switch">
                    <input type="checkbox" id="check-socle" checked>
                    <span class="slider"></span>
                </div>
            </label>
        </div>

        <span class="section-title">Matériaux & Finition</span>
        <div class="control-group">
            <div class="color-grid" id="colors">
                <div class="btn-color active" title="Blanc Mat" style="background-color: #ffffff; box-shadow: inset 0 0 0 1px #eee;" data-color="#ffffff"></div>
                <div class="btn-color" title="Noir Graphite" style="background-color: #1a1a1a;" data-color="#1a1a1a"></div>
                <div class="btn-color" title="Beige Sable" style="background-color: #e5dace;" data-color="#e5dace"></div>
                <div class="btn-color" title="Bois Naturel" style="background-color: #d2b48c;" data-color="#d2b48c"></div>
                <div class="btn-color" title="Gris Beton" style="background-color: #a0a0a0;" data-color="#a0a0a0"></div>
            </div>
        </div>
        
        <div class="hint">
            <b>NAVIGATION SMART</b>
            Pivotez avec un doigt, zoomez avec deux. 
            Cliquez sur un élément du meuble pour interagir directement.
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- SETUP SCENE ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xf0f0f0);
        
        const camera = new THREE.PerspectiveCamera(35, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(5, 2.5, 6);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.VSMShadowMap; // Ombres plus douces (VSM)
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        renderer.toneMapping = THREE.LinearToneMapping;
        renderer.toneMappingExposure = 1.0;
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.minDistance = 2;
        controls.maxDistance = 8;
        controls.maxPolarAngle = Math.PI / 2 - 0.05; // Empêche de passer sous le sol
        controls.target.set(0, 1, 0);

        // --- LIGHTING ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 1.2);
        dirLight.position.set(5, 8, 5);
        dirLight.castShadow = true;
        dirLight.shadow.camera.left = -5;
        dirLight.shadow.camera.right = 5;
        dirLight.shadow.camera.top = 5;
        dirLight.shadow.camera.bottom = -5;
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        dirLight.shadow.radius = 8;
        dirLight.shadow.blurSamples = 25;
        dirLight.shadow.bias = -0.0001;
        scene.add(dirLight);

        const fillLight = new THREE.DirectionalLight(0xffffff, 0.4);
        fillLight.position.set(-5, 3, 2);
        scene.add(fillLight);

        // --- ROOM (SALON) ---
        function createRoom() {
            const roomGroup = new THREE.Group();
            
            // Murs
            const wallMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.9 });
            
            // Mur arrière
            const backWall = new THREE.Mesh(new THREE.PlaneGeometry(10, 4), wallMat);
            backWall.position.set(0, 2, -1.5);
            backWall.receiveShadow = true;
            roomGroup.add(backWall);
            
            // Mur gauche
            const leftWall = new THREE.Mesh(new THREE.PlaneGeometry(8, 4), wallMat);
            leftWall.rotation.y = Math.PI / 2;
            leftWall.position.set(-5, 2, 2);
            leftWall.receiveShadow = true;
            roomGroup.add(leftWall);

            // Sol (Parquet)
            const floorGeo = new THREE.PlaneGeometry(10, 8);
            const floorMat = new THREE.MeshStandardMaterial({ 
                color: 0xffffff, 
                roughness: 0.9,
                metalness: 0
            });
            const floor = new THREE.Mesh(floorGeo, floorMat);
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            roomGroup.add(floor);

            // Déco simple (Plinthe)
            const plintheGeo = new THREE.BoxGeometry(10, 0.1, 0.02);
            const plinthe = new THREE.Mesh(plintheGeo, wallMat);
            plinthe.position.set(0, 0.05, -1.49);
            roomGroup.add(plinthe);

            // Fenêtre simulée par une lumière plus forte d'un côté
            const windowLight = new THREE.RectAreaLight(0xffffff, 2, 2, 4);
            windowLight.position.set(-4.9, 2, 1);
            windowLight.lookAt(0, 1, 0);
            roomGroup.add(windowLight);

            // --- DECORATION (PLANTE) ---
            const plantGroup = new THREE.Group();
            
            // Pot
            const pot = new THREE.Mesh(
                new THREE.CylinderGeometry(0.15, 0.1, 0.3, 16),
                new THREE.MeshStandardMaterial({ color: 0x444444 })
            );
            pot.position.y = 0.15;
            pot.castShadow = true;
            plantGroup.add(pot);

            // Tiges et Feuilles (simples)
            const leafMat = new THREE.MeshStandardMaterial({ color: 0x2d5a27, roughness: 0.8 });
            for(let i = 0; i < 8; i++) {
                const leaf = new THREE.Mesh(new THREE.CapsuleGeometry(0.05, 0.4, 4, 8), leafMat);
                leaf.position.y = 0.5;
                leaf.rotation.set(Math.random(), i * Math.PI/4, Math.random());
                leaf.castShadow = true;
                plantGroup.add(leaf);
            }
            plantGroup.position.set(-1.8, 0, -1);
            roomGroup.add(plantGroup);

            // --- TABLEAU ---
            const frame = new THREE.Mesh(
                new THREE.BoxGeometry(0.8, 1.2, 0.02),
                new THREE.MeshStandardMaterial({ color: 0x111111 })
            );
            frame.position.set(-2.5, 2.2, -1.48);
            roomGroup.add(frame);

            return roomGroup;
        }
        scene.add(createRoom());

        // --- HUMAN SILHOUETTE (PRO) ---
        function createHuman() {
            const group = new THREE.Group();
            const mat = new THREE.MeshBasicMaterial({ color: 0x000000, transparent: true, opacity: 0.12 });
            
            // Jambes
            const legGeo = new THREE.CapsuleGeometry(0.08, 0.7, 4, 8);
            const legL = new THREE.Mesh(legGeo, mat);
            legL.position.set(-0.12, 0.4, 0);
            group.add(legL);
            
            const legR = new THREE.Mesh(legGeo, mat);
            legR.position.set(0.12, 0.4, 0);
            group.add(legR);

            // Tronc / Torse
            const torsoGeo = new THREE.CapsuleGeometry(0.18, 0.6, 4, 8);
            const torso = new THREE.Mesh(torsoGeo, mat);
            torso.position.y = 1.1;
            group.add(torso);
            
            // Bras
            const armGeo = new THREE.CapsuleGeometry(0.06, 0.6, 4, 8);
            const armL = new THREE.Mesh(armGeo, mat);
            armL.position.set(-0.25, 1.1, 0);
            armL.rotation.z = 0.1;
            group.add(armL);

            const armR = new THREE.Mesh(armGeo, mat);
            armR.position.set(0.25, 1.1, 0);
            armR.rotation.z = -0.1;
            group.add(armR);

            // Tête
            const headGeo = new THREE.SphereGeometry(0.11, 16, 16);
            const head = new THREE.Mesh(headGeo, mat);
            head.position.y = 1.65;
            group.add(head);
            
            group.position.set(1.5, 0, 0.8);
            return group;
        }
        scene.add(createHuman());

        // --- FURNITURE ENGINE ---
        let furnitureGroup = new THREE.Group();
        scene.add(furnitureGroup);

        const config = {
            width: 1.5,
            height: 2.0,
            depth: 0.4,
            shelves: 4,
            color: '#ffffff',
            thickness: 0.02,
            hasDoors: true,
            hasSocle: true,
            doorOpen: false,
            shelfColors: {}
        };

        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        function buildFurniture() {
            // Clear previous
            while(furnitureGroup.children.length > 0) furnitureGroup.remove(furnitureGroup.children[0]);

            const mainMat = new THREE.MeshStandardMaterial({ 
                color: config.color,
                roughness: 0.15, // Plus de reflets pour le réalisme
                metalness: 0.02
            });

            const sideHeight = config.hasSocle ? config.height - 0.1 : config.height;
            const yOffset = config.hasSocle ? 0.1 : 0;

            // Sides
            const sideGeo = new THREE.BoxGeometry(config.thickness, sideHeight, config.depth);
            const leftSide = new THREE.Mesh(sideGeo, mainMat);
            leftSide.position.set(-config.width/2 + config.thickness/2, sideHeight/2 + yOffset, 0);
            leftSide.castShadow = true; leftSide.receiveShadow = true;
            furnitureGroup.add(leftSide);

            const rightSide = new THREE.Mesh(sideGeo, mainMat);
            rightSide.position.set(config.width/2 - config.thickness/2, sideHeight/2 + yOffset, 0);
            rightSide.castShadow = true; rightSide.receiveShadow = true;
            furnitureGroup.add(rightSide);

            // Top / Bottom
            const shelfWidth = config.width - (config.thickness * 2);
            const topGeo = new THREE.BoxGeometry(shelfWidth, config.thickness, config.depth);
            const top = new THREE.Mesh(topGeo, mainMat);
            top.position.set(0, config.height - config.thickness/2, 0);
            top.castShadow = true; top.receiveShadow = true;
            furnitureGroup.add(top);

            const bottom = new THREE.Mesh(topGeo, mainMat);
            bottom.position.set(0, yOffset + config.thickness/2, 0);
            bottom.castShadow = true; bottom.receiveShadow = true;
            furnitureGroup.add(bottom);

            // Shelves
            const internalHeight = sideHeight - (config.thickness * 2);
            const shelfSpacing = internalHeight / (parseInt(config.shelves) + 1);
            for(let i = 1; i <= config.shelves; i++) {
                const sColor = config.shelfColors[i] || config.color;
                const sMat = new THREE.MeshStandardMaterial({ color: sColor, roughness: 0.15 });
                const shelf = new THREE.Mesh(topGeo, sMat);
                shelf.position.set(0, yOffset + i * shelfSpacing + config.thickness, 0);
                shelf.castShadow = true; shelf.receiveShadow = true;
                shelf.userData = { type: 'shelf', index: i };
                furnitureGroup.add(shelf);
            }

            // Socle
            if (config.hasSocle) {
                const socleGeo = new THREE.BoxGeometry(config.width, 0.1, config.depth - 0.02);
                const socle = new THREE.Mesh(socleGeo, mainMat);
                socle.position.set(0, 0.05, -0.01);
                socle.castShadow = true; socle.receiveShadow = true;
                furnitureGroup.add(socle);
            }

            // Back
            const backGeo = new THREE.BoxGeometry(config.width - 0.01, sideHeight - 0.01, 0.005);
            const back = new THREE.Mesh(backGeo, mainMat);
            back.position.set(0, sideHeight/2 + yOffset, -config.depth/2 + 0.003);
            furnitureGroup.add(back);

            // Doors
            if (config.hasDoors) {
                const doorW = config.width / 2 - 0.005;
                const doorGeo = new THREE.BoxGeometry(doorW, sideHeight - 0.01, 0.018);
                const doorMat = new THREE.MeshStandardMaterial({ color: config.color, roughness: 0.1, metalness: 0.02 });

                // Pivot Left
                const pivotL = new THREE.Group();
                pivotL.position.set(-config.width/2, sideHeight/2 + yOffset, config.depth/2);
                furnitureGroup.add(pivotL);
                
                const doorL = new THREE.Mesh(doorGeo, doorMat);
                doorL.position.set(doorW/2, 0, 0.01);
                doorL.castShadow = true;
                doorL.userData = { type: 'door' };
                pivotL.add(doorL);

                // Pivot Right
                const pivotR = new THREE.Group();
                pivotR.position.set(config.width/2, sideHeight/2 + yOffset, config.depth/2);
                furnitureGroup.add(pivotR);

                const doorR = new THREE.Mesh(doorGeo, doorMat);
                doorR.position.set(-doorW/2, 0, 0.01);
                doorR.castShadow = true;
                doorR.userData = { type: 'door' };
                pivotR.add(doorR);

                if (config.doorOpen) {
                    pivotL.rotation.y = -Math.PI * 0.7;
                    pivotR.rotation.y = Math.PI * 0.7;
                }

                const handleGeo = new THREE.CylinderGeometry(0.008, 0.008, 0.2, 12);
                const handleMat = new THREE.MeshStandardMaterial({ color: 0x111111, metalness: 0.9, roughness: 0.1 });
                const hL = new THREE.Mesh(handleGeo, handleMat);
                hL.position.set(doorW/2 - 0.04, 0, 0.02);
                doorL.add(hL);
                const hR = new THREE.Mesh(handleGeo, handleMat);
                hR.position.set(-doorW/2 + 0.04, 0, 0.02);
                doorR.add(hR);
            }
        }

        buildFurniture();

        // --- INTERACTION ---
        function onPointerDown(event) {
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(furnitureGroup.children, true);

            if (intersects.length > 0) {
                let obj = intersects[0].object;
                let data = obj.userData;
                if (!data.type && obj.parent && obj.parent.userData.type) {
                    data = obj.parent.userData;
                }

                if (data.type === 'door') {
                    config.doorOpen = !config.doorOpen;
                    buildFurniture();
                } else if (data.type === 'shelf') {
                    const colors_list = ['#ffffff', '#2a2a2a', '#d8c7a1', '#5d4037', '#9e9e9e'];
                    const currentIdx = colors_list.indexOf(config.shelfColors[data.index] || config.color);
                    config.shelfColors[data.index] = colors_list[(currentIdx + 1) % colors_list.length];
                    buildFurniture();
                }
            }
        }
        window.addEventListener('pointerdown', onPointerDown);

        // --- UI EVENTS ---
        document.getElementById('input-width').addEventListener('input', (e) => {
            config.width = e.target.value / 100;
            document.getElementById('val-width').innerText = e.target.value + ' cm';
            buildFurniture();
        });
        document.getElementById('input-height').addEventListener('input', (e) => {
            config.height = e.target.value / 100;
            document.getElementById('val-height').innerText = e.target.value + ' cm';
            buildFurniture();
        });
        document.getElementById('input-depth').addEventListener('input', (e) => {
            config.depth = e.target.value / 100;
            document.getElementById('val-depth').innerText = e.target.value + ' cm';
            buildFurniture();
        });
        document.getElementById('input-shelves').addEventListener('input', (e) => {
            config.shelves = e.target.value;
            document.getElementById('val-shelves').innerText = e.target.value;
            buildFurniture();
        });
        document.getElementById('check-doors').addEventListener('change', (e) => {
            config.hasDoors = e.target.checked;
            buildFurniture();
        });
        document.getElementById('check-socle').addEventListener('change', (e) => {
            config.hasSocle = e.target.checked;
            buildFurniture();
        });
        document.querySelectorAll('.btn-color').forEach(btn => {
            btn.addEventListener('click', (e) => {
                document.querySelectorAll('.btn-color').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                config.color = btn.dataset.color;
                buildFurniture();
            });
        });

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        window.addEventListener('resize', () => {
            const width = document.getElementById('canvas-container').clientWidth;
            const height = document.getElementById('canvas-container').clientHeight;
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            renderer.setSize(width, height);
        });
        
        // Initial trigger
        window.dispatchEvent(new Event('resize'));
        animate();
    </script>
</body>
</html>